import os
import sys
import javalang


def main():
  # Get these two pieces of info from the command line args
  PREDICTIONS_FILE_PATH = sys.argv[1]
  DATASETS_DIR = sys.argv[2]

  def tryparse(curr_file, line_num):
    '''
    Attempts to apply the suggested repair to the line
    indicated by <line_num>.

    Returns True if file is parseable (after repair)
            False otherwise
    '''
    # Build the correct path
    target_file_path = os.path.join(
      DATASETS_DIR, '{}.txt'.format(curr_file)
    )

    # Open and try to parse
    with open(target_file_path) as the_file:
      # Get all of the lines
      L = the_file.readlines()

      # Apply the 'patch'
      # (line_num is one-based offset one more because first line is repair)
      L[line_num + 1] = L[0]
      L[0] = ""

      try:
        # Try to parse
        javalang.parser.parse(javalang.tokenizer.tokenize(''.join(L)))
        return True
      except:
        # Couldn't parse!
        return False

  def report(file_num, line_num):
    '''
    Prints our guess using the correct format
    '''
    print('{} {}'.format(
      os.path.join(DATASETS_DIR, '{}.txt'.format(file_num)),
      line_num
    ))

  # Open the predictions generated by RankLib
  with open(PREDICTIONS_FILE_PATH) as predictions:
    # We start with the 1st task
    curr_file=1
    # We don't have any best fix yet
    best, second_best=(None, None)

    # Need to lightly process predictions file
    read_predictions=lambda: [
      (int(task_num), int(line_num) + 1, float(score)) \
        for (task_num, line_num, score) in [
          line.split('\t') for line in predictions.readlines()
        ]
      ]

    # Now, go through each prediction and produce a guess
    for task_num, line_num, score in read_predictions():
      if curr_file != task_num:
        # If we're here, then we have a new file (and need to
        # report our best guess for the previous file)

        # If we CANT parse the file with the current path
        # and we COULD HAVE originally (with no fix)
        # then revert to second best
        if not tryparse(curr_file, best[1]):  # First check if we can't
          if tryparse(curr_file, -1):         # Then check if we could have
            # Replace
            best=second_best if second_best is not None else best

        # Report
        report(curr_file, best[1] if best is not None else 1)

        # Reset values
        curr_file=task_num
        best, second_best=(None, None)

      # Just see if we've found a better guess (based on score)
      if best is None or score >= best[0]:
        second_best=best
        best=(score, line_num)

    # Make sure we report for the last file too
    report(curr_file, best[1] if best is not None else 1)


if __name__ == "__main__":
    main()
